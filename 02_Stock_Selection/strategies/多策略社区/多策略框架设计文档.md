# 聚宽多策略框架设计文档

## 概述

本文档介绍了一种基于聚宽平台的模块化多策略框架设计，该框架通过面向对象的设计模式，实现了多个子策略的统一管理和独立运行。该框架具有高度的可扩展性、可维护性和灵活性，特别适合复杂的量化交易策略开发。

## 框架核心特性

### 1. 模块化设计
- **策略基类**：提供统一的接口和公共方法
- **子策略继承**：每个子策略继承基类，实现特定的交易逻辑
- **独立运行**：各子策略可以独立配置资金比例和执行时间

### 2. 资金管理
- **资金分配**：通过配置数组灵活分配各策略资金比例
- **现金管理**：利用货币ETF进行闲置资金管理
- **动态调仓**：支持不同策略的独立调仓逻辑

### 3. 风险控制
- **涨停保护**：自动识别和处理涨停股票
- **停牌过滤**：过滤停牌、ST等特殊股票
- **滑点控制**：设置合理的交易滑点和手续费

## 框架架构

### 核心组件

#### 1. 全局配置层
```python
# 全局变量配置
g.fill_stock = "511880.XSHG"  # 货币ETF用于现金管理
g.strategys = {}  # 策略对象字典
g.portfolio_value_proportion = [0.3, 0.2, 0.1, 0.1, 0.3]  # 资金分配比例
g.positions = {i: {} for i in range(len(g.portfolio_value_proportion))}  # 持仓记录
```

#### 2. 策略基类 (Strategy)
```python
class Strategy:
    def __init__(self, context, index, name):
        self.context = context
        self.index = index  # 策略索引，对应资金分配和持仓记录
        self.name = name
        self.stock_sum = 1  # 默认持仓股票数量
        self.hold_list = []  # 当前持仓列表
        self.min_volume = 2000  # 最小交易额
    
    # 核心方法
    def get_total_value(self):  # 计算策略持仓市值
    def _adjust(self, target):  # 等权调仓
    def _adjust2(self, targets):  # 指定市值调仓
    def order_target_value_(self, security, value):  # 安全下单
    def filter_basic_stock(self, stock_list):  # 基础股票过滤
```

#### 3. 子策略实现
每个子策略继承基类，实现特定的交易逻辑：

- **搅屎棍策略 (JSG)**：基于市场宽度和行业轮动的择时策略
- **全天候策略 (AllDay)**：ETF组合的资产配置策略
- **简单ROA策略 (SimpleROA)**：基于财务指标的选股策略
- **弱周期价投策略 (WeakCyc)**：价值投资策略
- **核心资产轮动策略 (EtfRotation)**：ETF轮动策略

### 框架优势

#### 1. 高度模块化
- **独立开发**：每个子策略可以独立开发和测试
- **代码复用**：公共功能在基类中实现，避免重复代码
- **易于维护**：修改某个策略不影响其他策略

#### 2. 灵活配置
- **资金分配**：通过修改比例数组轻松调整各策略资金分配
- **执行时间**：每个策略可以设置不同的执行时间
- **策略开关**：通过设置资金比例为0来关闭某个策略

#### 3. 风险控制
- **涨停保护**：自动处理涨停股票，避免流动性风险
- **异常处理**：下单过程中的异常情况得到妥善处理
- **资金管理**：通过货币ETF实现闲置资金的合理利用

#### 4. 扩展性强
- **新策略添加**：只需继承基类并实现必要方法
- **参数调整**：策略参数可以独立调整
- **功能扩展**：可以轻松添加新的公共功能

## 实现细节

### 1. 初始化流程
```python
def initialize(context):
    # 1. 设置基础选项
    set_option("avoid_future_data", True)
    set_option("use_real_price", True)
    
    # 2. 配置交易成本
    set_slippage(FixedSlippage(0.002), type="fund")
    set_slippage(FixedSlippage(0.02), type="stock")
    set_order_cost(...)
    
    # 3. 初始化全局变量
    g.fill_stock = "511880.XSHG"
    g.strategys = {}
    g.portfolio_value_proportion = [0.3, 0.2, 0.1, 0.1, 0.3]
    g.positions = {i: {} for i in range(len(g.portfolio_value_proportion))}
    
    # 4. 设置策略调度
    if g.portfolio_value_proportion[0] > 0:
        run_weekly(jsg_adjust, 1, "11:00")
        run_daily(jsg_check, "14:50")
    # ... 其他策略调度
    
    # 5. 初始化策略对象
    process_initialize(context)
```

### 2. 策略调度机制
```python
def process_initialize(context):
    g.strategys["搅屎棍策略"] = JSG(context, index=0, name="搅屎棍策略")
    g.strategys["全天候策略"] = AllDay(context, index=1, name="全天候策略")
    g.strategys["简单ROA策略"] = SimpleROA(context, index=2, name="简单ROA策略")
    g.strategys["弱周期价投策略"] = WeakCyc(context, index=3, name="弱周期价投策略")
    g.strategys["核心资产轮动策略"] = EtfRotation(context, index=4, name="核心资产轮动策略")
```

### 3. 资金管理机制
```python
def get_cash(context, value):
    """当现金不足时，卖出货币ETF获取资金"""
    if g.fill_stock not in context.portfolio.positions:
        return
    current_data = get_current_data()
    amount = math.ceil(value / current_data[g.fill_stock].last_price / 100) * 100
    position = context.portfolio.positions[g.fill_stock].closeable_amount
    if amount >= 100:
        order(g.fill_stock, -min(amount, position))
```

### 4. 安全下单机制
```python
def order_target_value_(self, security, value):
    """安全下单，包含各种风险检查"""
    current_data = get_current_data()
    
    # 检查停牌
    if current_data[security].paused:
        return False
    
    # 检查涨跌停
    if current_data[security].last_price == current_data[security].high_limit:
        return False
    if current_data[security].last_price == current_data[security].low_limit:
        return False
    
    # 执行下单
    price = current_data[security].last_price
    current_position = g.positions[self.index].get(security, 0)
    target_position = (int(value / price) // 100) * 100 if price != 0 else 0
    adjustment = target_position - current_position
    
    if adjustment != 0:
        o = order(security, adjustment)
        if o:
            # 更新持仓记录
            g.positions[self.index][security] = target_position
            if target_position == 0:
                g.positions[self.index].pop(security, None)
            return True
    return False
```

## 使用聚宽平台的优势

### 1. 数据支持
- **丰富的数据源**：股票、ETF、基本面数据、技术指标等
- **实时数据**：支持实时行情和基本面数据获取
- **历史数据**：完整的历史数据支持回测

### 2. 交易功能
- **订单管理**：完整的订单系统，支持各种订单类型
- **风险控制**：内置的风险控制机制
- **滑点模拟**：真实的交易成本模拟

### 3. 回测环境
- **历史回测**：完整的历史数据回测功能
- **实盘交易**：支持实盘交易执行
- **性能分析**：详细的策略性能分析

### 4. 开发便利
- **Python环境**：基于Python的友好开发环境
- **丰富API**：完整的API接口支持
- **文档完善**：详细的开发文档和示例

## 最佳实践

### 1. 策略设计原则
- **单一职责**：每个子策略专注于特定的投资逻辑
- **参数化配置**：策略参数应该可配置
- **风险控制**：每个策略都应该有适当的风险控制

### 2. 代码组织
- **模块化**：将不同功能分离到不同的模块
- **注释完善**：关键逻辑要有详细注释
- **错误处理**：适当的异常处理机制

### 3. 测试和调试
- **单元测试**：对关键功能进行单元测试
- **回测验证**：通过历史数据验证策略有效性
- **日志记录**：详细的日志记录便于调试

## 总结

这种多策略框架设计具有以下显著优势：

1. **高度模块化**：便于开发和维护
2. **灵活配置**：支持动态调整策略参数
3. **风险控制**：完善的风险控制机制
4. **扩展性强**：易于添加新策略
5. **聚宽平台优势**：充分利用聚宽的数据和交易功能

该框架特别适合需要管理多个策略的量化交易场景，能够有效提高开发效率和策略的稳定性。
